<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Study Features — SynapseStudy</title>
    <link rel="stylesheet" href="./styles.css" />
  </head>
  <body>
    <nav class="topbar">
      <div class="brand">SynapseStudy</div>
      <a class="back-link" href="./index.html">← Back</a>
    </nav>
    <main class="content">
      <section id="featuresSection" class="hidden" aria-hidden="true">
        <h1>Study Features</h1>
        <div class="features-form" id="featuresForm">
          <div class="feature">
            <label for="feature1">
              <input type="checkbox" id="feature1" />
              Recognize Patterns
            </label>
          </div>

          <div class="feature">
            <label for="feature2">
              <input type="checkbox" id="feature2" />
              Step by step solving
            </label>
          </div>

          <div class="feature">
            <label for="feature3">
              <input type="checkbox" id="feature3" />
              Flash cards
            </label>
          </div>

          <div class="feature">
            <label for="feature4">
              <input type="checkbox" id="feature4" />
              Practice prompts or problems
            </label>
          </div>
      </div>

      <!-- Solution is now shown in a separate modal overlay when triggered -->
      </section>

      <!-- Search bar at the bottom; triggers the features to pop up above -->
      <form id="searchForm" class="search-bar" role="search" aria-label="Study search">
        <input
          id="searchInput"
          class="search-input"
          type="search"
          placeholder="Search a topic to enable features..."
          autocomplete="off"
          aria-label="Search topic"
          required
        />
        <button class="search-btn" type="submit">Search</button>
      </form>
    </main>

    <!-- Modal overlay for the step-by-step solution -->
    <div id="solutionLayer" class="overlay hidden" aria-hidden="true">
      <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="solutionTitle">
        <button id="solutionClose" class="close-btn" aria-label="Close">×</button>
        <h2 id="solutionTitle">Step-by-step Solution</h2>
        <div id="solutionContent" class="solution-content"></div>
      </div>
    </div>

    <script>
      (function () {
        // Toggle features visibility based on search
        const searchForm = document.getElementById('searchForm');
        const searchInput = document.getElementById('searchInput');
        const featuresSection = document.getElementById('featuresSection');
        const feature2 = document.getElementById('feature2');
        const solutionLayer = document.getElementById('solutionLayer');
        const solutionClose = document.getElementById('solutionClose');
        const dialog = solutionLayer ? solutionLayer.querySelector('.dialog') : null;
        let revealedOnce = false;

        function revealFeatures() {
          if (!featuresSection) return;
          featuresSection.classList.remove('hidden');
          featuresSection.setAttribute('aria-hidden', 'false');
          revealedOnce = true;
        }

        function openOverlay() {
          if (!solutionLayer) return;
          solutionLayer.classList.remove('hidden');
          solutionLayer.setAttribute('aria-hidden', 'false');
          // Focus the dialog for accessibility
          if (dialog && dialog instanceof HTMLElement) dialog.focus();
          document.body.classList.add('modal-open');
        }

        function closeOverlay() {
          if (!solutionLayer) return;
          solutionLayer.classList.add('hidden');
          solutionLayer.setAttribute('aria-hidden', 'true');
          document.body.classList.remove('modal-open');
        }

        // Restore reveal state if user searched before
        const priorQuery = localStorage.getItem('study_search_query');
        if (priorQuery && searchInput instanceof HTMLInputElement) {
          searchInput.value = priorQuery;
          revealFeatures();
        }

        if (searchForm && searchInput instanceof HTMLInputElement) {
          searchForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const q = searchInput.value.trim();
            if (!q) return;
            localStorage.setItem('study_search_query', q);
            // First submit reveals features only
            if (!revealedOnce) {
              revealFeatures();
              return;
            }
            // Subsequent submit: only show overlay and fetch if step-by-step is checked
            const stepChecked = feature2 instanceof HTMLInputElement ? feature2.checked : false;
            if (stepChecked) {
              openOverlay();
              const contentEl = document.getElementById('solutionContent');
              if (contentEl) {
                contentEl.textContent = `Generating a step-by-step solution for: "${q}" …`;
              }
              // Call backend to generate the solution using the desired template
              fetch('/api/step-by-step', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query: q })
              })
                .then(async (r) => {
                  if (!r.ok) throw new Error(`Request failed: ${r.status}`);
                  return r.json();
                })
                .then((data) => {
                  const el = document.getElementById('solutionContent');
                  if (!el) return;
                  const txt = typeof data?.content === 'string' ? data.content : '';
                  if (!txt) {
                    el.textContent = 'No response received. Try again.';
                    return;
                  }
                  // Render as simple paragraphs; preserve newlines
                  el.innerHTML = '';
                  txt.split('\n').forEach((line) => {
                    const p = document.createElement('p');
                    p.textContent = line;
                    el.appendChild(p);
                  });
                })
                .catch((err) => {
                  const el = document.getElementById('solutionContent');
                  if (el) {
                    el.textContent = `Error generating solution: ${err instanceof Error ? err.message : String(err)}`;
                  }
                });
            }
          });
        }

        const features = ['feature1', 'feature2', 'feature3', 'feature4'];

        // Restore checkbox state and persist changes
        features.forEach((id) => {
          const boxEl = document.getElementById(id);
          if (!(boxEl instanceof HTMLInputElement)) return;
          const savedChecked = localStorage.getItem(id);
          if (savedChecked !== null) boxEl.checked = savedChecked === '1';
          boxEl.addEventListener('change', () => {
            localStorage.setItem(id, boxEl.checked ? '1' : '0');
          });
        });

        // Overlay close interactions
        if (solutionClose) {
          solutionClose.addEventListener('click', () => closeOverlay());
        }
        if (solutionLayer) {
          solutionLayer.addEventListener('click', (ev) => {
            if (ev.target === solutionLayer) closeOverlay();
          });
        }
        document.addEventListener('keydown', (ev) => {
          if (ev.key === 'Escape') closeOverlay();
        });

        // No save button; state persists automatically via localStorage
      })();
    </script>
  </body>
  </html>
